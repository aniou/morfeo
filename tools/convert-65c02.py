#!/usr/bin/python3

import fileinput
import re

addr_mode = {
    'abs': 'mode_Absolute_DBR',
    'abs,X': 'mode_Absolute_X',
    'abs,Y': 'mode_Absolute_Y',
    'acc': 'mode_Accumulator',
    'imm': 'mode_Immediate',
    'imp': 'mode_Implied',
    'dir': 'mode_DP',
    'dir,X': 'mode_DP_X',
    'dir,Y': 'mode_DP_Y',
    '(dir,X)': 'mode_DP_X_Indirect',
    '(dir)': 'mode_DP_Indirect',
    '[dir]': 'mode_DP_Indirect_Long',
    '(dir),Y': 'mode_DP_Indirect_Y',
    '[dir],Y': 'mode_DP_Indirect_Long_Y',
    '(abs,X)': 'mode_Absolute_X_Indirect',
    '(abs)': 'mode_Absolute_Indirect',
    '[abs]': 'mode_Absolute_Indirect_Long',
    'long': 'mode_Absolute_Long',
    'long,X': 'mode_Absolute_Long_X',
    'src,dest': 'mode_BlockMove',
    'rel8': 'mode_PC_Relative',
    'rel16': 'mode_PC_Relative_Long',
    'stk,S': 'mode_S_Relative',
    '(stk,S),Y': 'mode_S_Relative_Indirect_Y',

    'rel': 'mode_PC_Relative',
    '(zp,X)': 'mode_DP_X_Indirect',
    'zp': 'mode_DP',
    'zp,X': 'mode_DP_X',
    'zp,Y': 'mode_DP_Y',
    'zp,rel': 'mode_ZP_and_Relative',
    '(zp),Y': 'mode_ZP_Indirect_Y',
    '(zp)': 'mode_DP_Indirect',
}


print("""
// autogenerated by convert-6502.py from w65c02s_commands-ordered.txt file

execute_w65c02s :: proc(cpu: ^CPU_65C816) {
    switch (cpu.ir) {
""")

#counter = 0
for line in fileinput.input("w65c02s_commands-ordered.txt", openhook=fileinput.hook_encoded("utf-8")):
    match = re.search(r'^[0-9A-F][0-9A-F] ', line)
    if not match:
        continue

    t = line.split()
    if len(t) < 2:
        print("ERR: bad line %s" % (line))
        continue

    #print(t)

    opcode = int(t[0], 16)
    #while counter < opcode:
    #    print("\t\t{0x%02x, \"XXX\", m_Implied,                   1, 1, c.xxx},\t// illegal/unknown opcode" % counter)
    #    counter+=1


    opname = t[5].upper()

    desc   = "// %-14s %s  %s" % (' '.join(t[5:]), t[1], t[2])
    cycles = t[2][0:1]

    if opname == 'BBS':
        opname="BBS%s" % t[6].split(',')[0]
        
    if opname == 'BBR':
        opname="BBR%s" % t[6].split(',')[0]

    if opname == 'RMB':
        opname="RMB%s" % t[6].split(',')[0]

    if opname == 'SMB':
        opname="SMB%s" % t[6].split(',')[0]


    if t[1].endswith('-m'):
        size    = int(t[1][:-2])
        mode    = 'mode_Immediate_flag_M'
    elif t[1].endswith('-x'):
        size    = int(t[1][:-2])
        mode    = 'mode_Immediate_flag_X'
    else:
        size    = int(t[1])
        mode    = addr_mode[t[3]]

    if opname=='PER':
        mode    = 'mode_PC_Relative_Long'

    if opname=='JMP' and mode=='mode_Absolute_DBR':
        mode    = 'mode_Absolute_PBR'

    if opname=='JSR' and mode=='mode_Absolute_DBR':
        mode    = 'mode_Absolute_PBR'

    if opname=='BIT' and mode=='mode_Immediate_flag_M':
        opname='BIT_IMM'

    if opname=='BIT' and mode=='mode_Immediate':
        opname='BIT_IMM'

    if t[3] == 'acc':
        opname = opname + "_A"

    if opname == '-':
        opname="ILL"
        mode  ="mode_Illegal%s" % t[1]

    if opname == 'SBC':
        opname="SBC_65C02"

    #counter+=1

    hexopcode="0x%02x" % opcode
    # {0x00, "brk", m_Implied, 1, 8, c.brk},
    # mode=mode+','
    #print("\t\t{0x%02x, \"%s\", %-28s %i, %s, c.%s},\t%s" % (opcode, opname, mode, size, cycles, opname, desc))
    #print(hexopcode, cycles, opname, size, mode, desc)
    print("    case 0x%02x:                                  %s" % (opcode, desc))
    print("        %-28s  (cpu)" % (mode))
    print("        %-28s  (cpu)" % ("oper_"+opname))
    print("")

print("""
    }
}
""")
